date: 2002/07/29 22:36:05;  author: rob;  state: Exp;  lines: +25 -0
IPV6 support (Matthias Wimmer <m@tthias.net>)

Index: configure
===================================================================
RCS file: /home/cvs/jabberd14/configure,v
retrieving revision 1.39
retrieving revision 1.40
diff -r1.39 -r1.40
14a15
> WANT_IPV6=0;
19a21,22
>       x--enable-ipv6)
>         WANT_IPV6=1;;
69a73,84
> fi;
> 
> ##
> # IPv6 check
> ##
> printf "Support for IPv6...";
> if [ $WANT_IPV6 -eq 1 ]; then
>     # we should add some checks if all the needed functions are available
>     printf "             Enabled.\n";
>     CFLAGS="$CFLAGS -DWITH_IPV6";
> else
>     printf "             Disabled.\n";
Index: dialback/dialback_out.c
===================================================================
RCS file: /home/cvs/jabberd14/dialback/dialback_out.c,v
retrieving revision 1.11
retrieving revision 1.13
diff -r1.11 -r1.13
101a102,125
> #ifdef WITH_IPV6
>     if(ip[0] == '[')
>     { /* format "[ipaddr]:port" or "[ipaddr]" */
> 	ip++;
> 	col=strchr(ip,']');
> 	if(col != NULL)
> 	{
> 	    *col = '\0';
> 	    if(col[1]==':')
> 	    {
> 		col++;
> 	    }
> 	}
>     }
>     else
>     { /* format "ipaddr" or "ipaddr:port" */
> 	col = strchr(ip, ':');
> 	/* if it has at least two colons it is an IPv6 address */
> 	if(col!=NULL && strchr(col+1,':'))
> 	{
> 	    col = NULL;
> 	}
>     }
> #else
102a127
> #endif
Index: dnsrv/srv_resolv.c
===================================================================
RCS file: /home/cvs/jabberd14/dnsrv/srv_resolv.c,v
retrieving revision 1.10
retrieving revision 1.11
diff -r1.10 -r1.11
68a69,76
> #ifdef WITH_IPV6
> char* srv_inet_ntop(pool p, const unsigned char* addrptr, int af)
> {
>     char result[INET6_ADDRSTRLEN];
>     inet_ntop(af, addrptr, result, sizeof(result));
>     return pstrdup(p, result);
> }
> #endif
93a102,106
> #ifdef WITH_IPV6
>      int	      error_code;
>      struct addrinfo  hints;
>      struct addrinfo* addr_res;
> #else
94a108
> #endif
99a114,146
> #ifdef WITH_IPV6
> 	  hints.ai_flags = 0;
> 	  hints.ai_family = PF_UNSPEC;
> 	  hints.ai_socktype = SOCK_STREAM;
> 	  hints.ai_protocol = 0;
> 	  hints.ai_addrlen = 0;
> 	  hints.ai_canonname = NULL;
> 	  hints.ai_addr = NULL;
> 	  hints.ai_next = NULL;
> 
> 	  error_code = getaddrinfo(domain, NULL, &hints, &addr_res);
> 	  if (error_code)
> 	  {
> 	      log_debug(ZONE, "srv: Error while resolving %s: %s", domain, gai_strerror(error_code));
> 	      return NULL;
> 	  }
> 
> 	  switch (addr_res->ai_family)
> 	  {
> 	      case PF_INET:
> 		  ipaddr = pstrdup(p, srv_inet_ntop(p, (char *)&((struct sockaddr_in*)addr_res->ai_addr)->sin_addr, addr_res->ai_family));
> 		  break;
> 	      case PF_INET6:
> 		  ipaddr = pstrdup(p, srv_inet_ntop(p, (char *)&((struct sockaddr_in6*)addr_res->ai_addr)->sin6_addr, addr_res->ai_family));
> 		  break;
> 	      default:
> 		  ipaddr = NULL;
> 	  }
> 
> 	  freeaddrinfo(addr_res);
> 	  log_debug(ZONE, "srv: Resolved %s to: %s", domain, ipaddr);
> 	  return ipaddr;
> #else
109a157
> #endif
175a224,236
> #ifdef WITH_IPV6
> 		   /* AAAA records should be hashed for the duration of this lookup */
> 	       case T_AAAA:
> 		   /* Allocate a new string to hold the IP address */
> 		   ipaddr = srv_inet_ntop(p, rrptr, AF_INET6);
> 		   /* Copy the domain name */
> 		   ipname = pstrdup(p, host);
> 
> 		   /* Insert name/ip into hash table for future reference */
> 		   ghash_put(arr_table, ipname, ipaddr);
> 
> 		   break;
> #endif
246c307,317
< 		    spooler(result, ipaddr, ":", iternode->port, result);
---
> #ifdef WITH_IPV6
> 	            if (strchr(ipaddr, ':')) {
> 			spooler(result, "[", ipaddr, "]:", iternode->port, result);
> 		    }
> 		    else
> 		    {
> #endif
> 		        spooler(result, ipaddr, ":", iternode->port, result);
> #ifdef WITH_IPV6
> 		    }
> #endif
250a322,359
> #ifdef WITH_IPV6
> 		    log_debug(ZONE, "srv: attempting A / AAAA record lookup.");
> 
> 		    hints.ai_flags = 0;
> 		    hints.ai_family = PF_UNSPEC;
> 		    hints.ai_socktype = SOCK_STREAM;
> 		    hints.ai_protocol = 0;
> 		    hints.ai_addrlen = 0;
> 		    hints.ai_canonname = NULL;
> 		    hints.ai_addr = NULL;
> 		    hints.ai_next = NULL;
> 
> 		    error_code = getaddrinfo(iternode->host, NULL, &hints, &addr_res);
> 		    if (error_code)
> 		    {
> 			log_debug(ZONE, "srv: Error while resolving %s: %s", domain, gai_strerror(error_code));
> 		    }
> 		    else
> 		    {
> 			switch (addr_res->ai_family)
> 			{
> 			    case PF_INET:
> 				spooler(result,
> 					srv_inet_ntop(p, (char *)&((struct sockaddr_in*)addr_res->ai_addr)->sin_addr, addr_res->ai_family),
> 					":", iternode->port, result);
> 				break;
> 			    case PF_INET6:
> 				spooler(result, "[",
> 					srv_inet_ntop(p, (char *)&((struct sockaddr_in6*)addr_res->ai_addr)->sin6_addr, addr_res->ai_family),
> 					"]:", iternode->port, result);
> 				break;
> 			    default:
> 				ipaddr = NULL;
> 			}
> 
> 			freeaddrinfo(addr_res);
> 		    }
> #else
261a371
> #endif
Index: jabberd/mio.c
===================================================================
RCS file: /home/cvs/jabberd14/jabberd/mio.c,v
retrieving revision 1.64
retrieving revision 1.66
diff -r1.64 -r1.66
91a92,140
> #ifdef WITH_IPV6
> int _mio_compare_ipv6(const struct in6_addr *addr1, const struct in6_addr *addr2, int netsize)
> {
>     int i;
>     u_int8_t mask;
> 
>     if(netsize > 128)
> 	netsize = 128;
> 
>     for(i = 0; i < netsize/8; i++)
>     {
> 	if(addr1->s6_addr[i] != addr2->s6_addr[i])
> 	    return 0;
>     }
> 
>     if (netsize%8 == 0)
> 	return 1;
> 
>     mask = 0xff << (8 - netsize%8);
> 
>     return ((addr1->s6_addr[i]&mask) == (addr2->s6_addr[i]&mask));
> }
> 
> int _mio_netmask_to_ipv6(const char *netmask)
> {
>     struct in_addr addr;
> 
>     if (netmask == NULL)
>     {
> 	return 128;
>     }
> 
>     if (inet_pton(AF_INET, netmask, &addr))
>     {
> 	uint32_t temp = ntohl(addr.s_addr);
> 	int netmask = 128;
> 
> 	while (netmask>96 && temp%2==0)
> 	{
> 	    netmask--;
> 	    temp /= 2;
> 	}
> 	return netmask;
>     }
> 
>     return atoi(netmask);
> }
> #endif
> 
93a143,148
> #ifdef WITH_IPV6
>     char temp_address[INET6_ADDRSTRLEN];
>     char temp_ip[INET6_ADDRSTRLEN];
>     static struct in_addr tmpa;
> #endif
>     
96a152,159
> #ifdef WITH_IPV6
>     if (inet_pton(AF_INET, address, &tmpa)) {
> 	strcpy(temp_address, "::ffff:");
> 	strcat(temp_address, address);
> 	address = temp_address;
>     }
> #endif
> 
102a166,169
> #ifdef WITH_IPV6
> 	struct in6_addr in_address, in_ip;
> 	int in_netmask;
> #else
103a171,172
> #endif
> 
115a185,194
> #ifdef WITH_IPV6
> 	if (inet_pton(AF_INET, ip, &tmpa))
> 	{
> 	    strcpy(temp_ip, "::ffff:");
> 	    strcat(temp_ip, ip);
> 	    ip = temp_ip;
> 	}
> 
> 	inet_pton(AF_INET6, address, &in_address);
> #else
116a196
> #endif
118a199,201
> #ifdef WITH_IPV6
> 	    inet_pton(AF_INET6, ip, &in_ip);
> #else
119a203
> #endif
122a207,211
> #ifdef WITH_IPV6
> 	    in_netmask = _mio_netmask_to_ipv6(netmask);
> 
> 	    if(_mio_compare_ipv6(&in_address, &in_ip, in_netmask))
> #else
124a214
> #endif
130a221,223
> #ifdef WITH_IPV6
> 	    if(_mio_compare_ipv6(&in_ip, &in_address, 128))
> #else
131a225
> #endif
141a236,241
> #ifdef WITH_IPV6
>     char temp_address[INET6_ADDRSTRLEN];
>     char temp_ip[INET6_ADDRSTRLEN];
>     static struct in_addr tmpa;
> #endif
> 
144a245,252
> #ifdef WITH_IPV6
>     if (inet_pton(AF_INET, address, &tmpa)) {
> 	strcpy(temp_address, "::ffff:");
> 	strcat(temp_address, address);
> 	address = temp_address;
>     }
> #endif
> 
150a259,262
> #ifdef WITH_IPV6
> 	struct in6_addr in_address, in_ip;
> 	int in_netmask;
> #else
151a264,265
> #endif
> 
163a278,287
> #ifdef WITH_IPV6
> 	if (inet_pton(AF_INET, ip, &tmpa))
> 	{
> 	    strcpy(temp_ip, ":ffff:");
> 	    strcat(temp_ip, ip);
> 	    ip = temp_ip;
> 	}
> 
> 	inet_pton(AF_INET6, address, &in_address);
> #else
164a289
> #endif
166a292,294
> #ifdef WITH_IPV6
> 	    inet_pton(AF_INET6, ip, &in_ip);
> #else
167a296
> #endif
170a300,304
> #ifdef WITH_IPV6
> 	    in_netmask = _mio_netmask_to_ipv6(netmask);
> 
> 	    if (_mio_compare_ipv6(&in_address, &in_ip, in_netmask))
> #else
172a307
> #endif
178a314,316
> #ifdef WITH_IPV6
> 	    if(_mio_compare_ipv6(&in_ip, &in_address, 128))
> #else
179a318
> #endif
373a513,516
> #ifdef WITH_IPV6
>     struct sockaddr_in6 serv_addr;
>     char addr_str[INET6_ADDRSTRLEN];
> #else
374a518
> #endif
388a533,536
> #ifdef WITH_IPV6
>     allow = _mio_allow_check(inet_ntop(AF_INET6, &serv_addr.sin6_addr, addr_str, sizeof(addr_str)));
>     deny = _mio_deny_check(addr_str);
> #else
390a539
> #endif
393a543,545
> #ifdef WITH_IPV6
> 	log_warn("mio", "%s was denied access, due to the allow list of IPs", addr_str);
> #else
394a547
> #endif
399a553,557
> #ifdef WITH_IPV6
>     if(m->rated && jlimit_check(m->rate, addr_str, 1))
>     {
> 	log_warn("io_select", "%s(%d) is being connection rate limited", addr_str, fd);
> #else
402a561
> #endif
406a566,568
> #ifdef WITH_IPV6
>     log_debug(ZONE, "new socket accepted (fd: %d, ip%s, port: %d)", fd, addr_str, ntohs(serv_addr.sin6_port));
> #else
407a570
> #endif
410a574,576
> #ifdef WITH_IPV6
>     new->ip  = pstrdup(new->p, addr_str);
> #else
411a578
> #endif
450a618,621
> #ifdef WITH_IPV6
>     struct sockaddr_in6 sa;
>     struct in6_addr	*saddr;
> #else
452a624
> #endif
464c636
<     bzero((void*)&sa, sizeof(struct sockaddr_in));
---
>     bzero((void*)&sa, sizeof(sa));
478c650,654
<     new->fd = socket(AF_INET, SOCK_STREAM,0);
---
> #ifdef WITH_IPV6
>     new->fd = socket(PF_INET6, SOCK_STREAM,0);
> #else
>     new->fd = socket(PF_INET, SOCK_STREAM,0);
> #endif
496a673,691
> #ifdef WITH_IPV6
> 	struct sockaddr_in6 sa;
> 	char *addr_str = xmlnode_get_tag_data(greymatter__, "io/bind");
> 	char temp_addr[INET6_ADDRSTRLEN];
> 	struct in_addr tmp;
> 
> 	if (inet_pton(AF_INET, addr_str, &tmp))
> 	{
> 	    strcpy(temp_addr, "::ffff:");
> 	    strcat(temp_addr, addr_str);
> 	    addr_str = temp_addr;
> 	}
> 
> 	sa.sin6_family = AF_INET6;
> 	sa.sin6_port = 0;
> 	sa.sin6_flowinfo = 0;
> 
> 	inet_pton(AF_INET6, addr_str, &sa.sin6_addr);
> #else
501c696,697
<         bind(new->fd, (struct sockaddr*)&sa, sizeof(struct sockaddr_in));
---
> #endif
>         bind(new->fd, (struct sockaddr*)&sa, sizeof(sa));
508a705,707
> #ifdef WITH_IPV6
>     saddr = make_addr_ipv6(cd->ip);
> #else
509a709
> #endif
522a723,727
> #ifdef WITH_IPV6
>     sa.sin6_family = AF_INET6;
>     sa.sin6_port = htons(cd->port);
>     sa.sin6_addr = *saddr;
> #else
525a731
> #endif
576a783,785
> #ifdef WITH_IPV6
>     char	addr_str[INET6_ADDRSTRLEN];
> #endif
633a843,845
> #ifdef WITH_IPV6
> 	    struct sockaddr_in6 remote_addr;
> #else
634a847
> #endif
639a853,855
> #ifdef WITH_IPV6
>             log_debug(ZONE,"ANNOUNCER: received some data from %s: %.*s",inet_ntop(AF_INET, &remote_addr.sin6_addr, addr_str, sizeof(addr_str)),len,buf);
> #else
640a857
> #endif
1171a1389,1398
> 
> #ifdef WITH_IPV6
>     if(!strchr(host,':'))
>     {
> 	char *temp = pmalloco(p, strlen(host)+8);
> 	strcpy(temp, "::ffff:");
> 	strcat(temp, host);
> 	host = temp;
>     }
> #endif
Index: jabberd/lib/lib.h
===================================================================
RCS file: /home/cvs/jabberd14/jabberd/lib/lib.h,v
retrieving revision 1.17
retrieving revision 1.19
diff -u -r1.17 -r1.19
--- jabberd/lib/lib.h	25 Jan 2002 16:13:31 -0000	1.17
+++ jabberd/lib/lib.h	4 Aug 2002 11:47:19 -0000	1.19
@@ -155,6 +155,9 @@
 int make_netsocket(u_short port, char *host, int type);
 struct in_addr *make_addr(char *host);
 int set_fd_close_on_exec(int fd, int flag);
+#ifdef WITH_IPV6
+struct in6_addr *make_addr_ipv6(char *host);
+#endif
 #endif
 
 
Index: jabberd/lib/socket.c
===================================================================
RCS file: /home/cvs/jabberd14/jabberd/lib/socket.c,v
retrieving revision 1.5
retrieving revision 1.7
diff -u -r1.5 -r1.7
--- jabberd/lib/socket.c	8 Feb 2002 07:44:14 -0000	1.5
+++ jabberd/lib/socket.c	4 Aug 2002 11:47:19 -0000	1.7
@@ -52,31 +52,53 @@
 int make_netsocket(u_short port, char *host, int type)
 {
     int s, flag = 1;
+#ifdef WITH_IPV6
+    struct sockaddr_in6 sa;
+    struct in6_addr *saddr;
+#else
     struct sockaddr_in sa;
     struct in_addr *saddr;
+#endif
     int socket_type;
 
     /* is this a UDP socket or a TCP socket? */
     socket_type = (type == NETSOCKET_UDP)?SOCK_DGRAM:SOCK_STREAM;
 
-    bzero((void *)&sa,sizeof(struct sockaddr_in));
+    bzero((void *)&sa,sizeof(sa));
 
-    if((s = socket(AF_INET,socket_type,0)) < 0)
+#ifdef WITH_IPV6
+    if((s = socket(PF_INET6,socket_type,0)) < 0)
+#else
+    if((s = socket(PF_INET,socket_type,0)) < 0)
+#endif
         return(-1);
     if(setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (char*)&flag, sizeof(flag)) < 0)
         return(-1);
 
+#ifdef WITH_IPV6
+    saddr = make_addr_ipv6(host);
+#else
     saddr = make_addr(host);
+#endif
     if(saddr == NULL && type != NETSOCKET_UDP)
         return(-1);
+#ifdef WITH_IPV6
+    sa.sin6_family = AF_INET6;
+    sa.sin6_port = htons(port);
+#else
     sa.sin_family = AF_INET;
     sa.sin_port = htons(port);
+#endif
 
     if(type == NETSOCKET_SERVER)
     {
         /* bind to specific address if specified */
         if(host != NULL)
+#ifdef WITH_IPV6
+	    sa.sin6_addr = *saddr;
+#else
             sa.sin_addr.s_addr = saddr->s_addr;
+#endif
 
         if(bind(s,(struct sockaddr*)&sa,sizeof sa) < 0)
         {
@@ -86,7 +108,11 @@
     }
     if(type == NETSOCKET_CLIENT)
     {
+#ifdef WITH_IPV6
+	sa.sin6_addr = *saddr;
+#else
         sa.sin_addr.s_addr = saddr->s_addr;
+#endif
         if(connect(s,(struct sockaddr*)&sa,sizeof sa) < 0)
         {
             close(s);
@@ -105,7 +131,11 @@
         /* if specified, use a default recipient for read/write */
         if(host != NULL && saddr != NULL)
         {
+#ifdef WITH_IPV6
+	    sa.sin6_addr = *saddr;
+#else
             sa.sin_addr.s_addr = saddr->s_addr;
+#endif
             if(connect(s,(struct sockaddr*)&sa,sizeof sa) < 0)
             {
                 close(s);
@@ -147,6 +177,104 @@
     }
     return NULL;
 }
+
+#ifdef WITH_IPV6
+void map_addr_to6(const struct in_addr *src, struct in6_addr *dest)
+{
+    uint32_t hip;
+
+    bzero(dest, sizeof(struct in6_addr));
+    dest->s6_addr[10] = dest->s6_addr[11] = 0xff;
+
+    hip = ntohl(src->s_addr);
+
+    dest->s6_addr[15] = hip % 256;
+    hip /= 256;
+    dest->s6_addr[14] = hip % 256;
+    hip /= 256;
+    dest->s6_addr[13] = hip % 256;
+    hip /= 256;
+    dest->s6_addr[12] = hip % 256;
+}
+
+struct in6_addr *make_addr_ipv6(char *host)
+{
+    static struct in6_addr addr;
+    struct addrinfo hints;
+    struct addrinfo *addr_res;
+    int error_code;
+
+    if(host == NULL || strlen(host) == 0)
+    {
+	char myname[MAXHOSTNAMELEN + 1];
+        gethostname(myname,MAXHOSTNAMELEN);
+
+	/* give the resolver hints on what we want */
+	bzero(&hints, sizeof(hints));
+	hints.ai_family = PF_UNSPEC;
+	hints.ai_socktype = SOCK_STREAM;
+
+	error_code = getaddrinfo(myname, NULL, &hints, &addr_res);
+	if(!error_code)
+	{
+	    switch(addr_res->ai_family)
+	    {
+		case PF_INET:
+		    map_addr_to6(&((struct sockaddr_in*)addr_res->ai_addr)->sin_addr, &addr);
+		    break;
+		case PF_INET6:
+		    addr = ((struct sockaddr_in6*)addr_res->ai_addr)->sin6_addr;
+		    break;
+		default:
+		    freeaddrinfo(addr_res);
+		    return NULL;
+	    }
+	    freeaddrinfo(addr_res);
+	    return &addr;
+	}
+    }else{
+	char tempname[INET6_ADDRSTRLEN];
+
+	/* IPv4 addresses have to be mapped to IPv6 */
+	if (inet_pton(AF_INET, host, &addr))
+	{
+	    strcpy(tempname, "::ffff:");
+	    strcat(tempname, host);
+	    host = tempname;
+	}
+	
+	if (inet_pton(AF_INET6, host, &addr))
+        {
+            return &addr;
+        }
+	
+	/* give the resolver hints on what we want */
+	bzero(&hints, sizeof(hints));
+	hints.ai_family = PF_UNSPEC;
+	hints.ai_socktype = SOCK_STREAM;
+
+	error_code = getaddrinfo(host, NULL, &hints, &addr_res);
+	if(!error_code)
+	{
+	    switch(addr_res->ai_family)
+	    {
+		case PF_INET:
+		    map_addr_to6(&((struct sockaddr_in*)addr_res->ai_addr)->sin_addr, &addr);
+		    break;
+		case PF_INET6:
+		    addr = ((struct sockaddr_in6*)addr_res->ai_addr)->sin6_addr;
+		    break;
+		default:
+		    freeaddrinfo(addr_res);
+		    return NULL;
+	    }
+	    freeaddrinfo(addr_res);
+	    return &addr;
+	}
+    }
+    return NULL;
+}
+#endif
 
 /* Sets a file descriptor to close on exec.  "flag" is 1 to close on exec, 0 to
  * leave open across exec.
